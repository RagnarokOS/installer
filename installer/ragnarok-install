#!/bin/ksh

# Main installer script.
# $Ragnarok: ragnarok-install,v 1.8 2024/04/21 16:01:06 lecorbeau Exp $

set -e

TMP=$(mktemp -d -p /tmp ragnarok-install.XXXXXXXXXX)
# Parse config values
CODENAME=$(awk '/Codename/ { print $3 }' install.conf)
FLAVOUR=$(awk '/Flavour/ { print $3 }' install.conf)
VARIANT=$(awk '/Variant/ { print $3 }' install.conf)
COMPONENTS=$(awk '/Components/ { print $3 }' install.conf)
MIRROR=$(awk '/Mirror/ { print $3 }' install.conf)
VERSION=$(awk 'Version/ { print $3 }' install.conf)
URL="${MIRROR}${VERSION}"

# Never download stuff off the internet as the root user.
# I take no credit for this function. All credit goes to
# Antoine Jacoutot, who wrote OpenBSD's syspatch(1).
unpriv() {
	local _file=$2 _ret=0 _user=_apt

	if [[ $1 == -f && -n ${_file} ]]; then
		# shellcheck disable=SC2188
		>${_file}
		chown "${_user}" "${_file}"
		chmod 0711 "${TMP}"
		shift 2
	fi
	(($# >= 1))

	su -s /bin/sh ${_user} -c "$@" || _ret=$?

	[[ -n ${_file} ]] && chown root "${_file}"

	return ${_ret}
}

# This is shorter than constantly writing the printf command
msg() {
	local _msg=$1

	printf '%s\n' "$_msg"
}

# Download the tarball
get_tarball() {
	local _file="miniroot${VERSION}.tgz"

	msg "Fetching ${_file}..."
	unpriv -f "${TMP}/${_file}" "wget -q --show-progress -P ${TMP} -O ${_file} ${URL}/${_file}"
}

# Extract miniroot.tgz
extract() {
	tar xzpvf "${TMP}/miniroot${VERSION}.tgz" --xattrs --xattrs-include='*' --numeric-owner -C /mnt
}

# Set up fstab
gfstab() {
	msg "Generating fstab entries..."
	genfstab -U /mnt >> /mnt/etc/fstab
}

# Copy network files
set_net() {
	msg "Setting up network interfaces"
	# Copy /etc/resolv.conf to the chroot, temporarily
	/usr/bin/cp /etc/resolv.conf "$1"/etc/resolv.conf

	# copy interfaces files.
	/usr/bin/cp /etc/network/interfaces "$1"/etc/network/
	/usr/bin/cp -r /etc/network/interfaces.d/ "$1"/etc/network/
}

# Setting the timezone
set_tz() {
	/usr/sbin/chroot "$1" dpkg-reconfigure tzdata
}

# Setup /etc/hosts and /etc/hostname
set_hosts() {
	local _resp

	read -r _resp?"Enter the hostname of the machine: "
	msg "$_resp" > "$1"/etc/hostname
	msg "127.0.0.1   localhost
127.0.1.1   $_resp


# IPv6
::1         localhost ip6-localhost ip6-loopback
ff02::1     ip6-allnodes
ff02::2     ip6-allrouters" > "$1"/etc/hosts
}

# Set locales and keyboard config
set_lokb() {
	msg "Setting up locales and keyboard config..."
	/usr/sbin/chroot "$1" apt-get install locales -y
	/usr/sbin/chroot "$1" dpkg-reconfigure locales
	/usr/sbin/chroot "$1" apt-get install console-setup -y
}

# Set root password
set_rootpass() {
	msg "Password for the root account (will not echo)"
	/usr/sbin/chroot "$1" passwd
}

# Setup a default user name and password
set_user() {
	local _resp

	read -r _resp?"Name of default user: "
	/usr/sbin/chroot "$1" useradd -m "$_resp"
	/usr/sbin/chroot "$1" usermod -aG wheel,cdrom,floppy,audio,dip,video,plugdev,netdev "$_resp"
	/usr/sbin/chroot "$1" usermod -s /bin/ksh "$_resp"

	msg "Password for $_resp (will not echo)"
	/usr/sbin/chroot passwd "$_resp"
}

inst_kern() {
	# First, install Debian's standard kernel as a back up.
	chroot "$1" apt-get install linux-image-amd64
	chroot "$1" kernupd
}

# Let user decide which set(s) to install.
# NOTE: This will need to be tested on its own first.
install_sets() {
	local _resp _sets

	read -r _resp?"The following sets will be installed:
[x] base    | The base system.
[x] devel   | The git, build-essential and LLVM/Clang toolchain.
[x] xfonts  | Extra fonts for xserv.
[x] xprogs  | Window Managers (Raven, cwm) + ragnarok-terminal and dmenu.
[x] xserv   | Minimal xorg + xinit.

To omit one or more set, simply type <setname> (e.g. xfonts, or xfonts xprogs xserv). Then press Return to install the sets: "

	# If no set was deselected, proceed, else remove deselected first.
	if [[ -z $_resp ]]; then
		_resp="all"
	fi

	case "$_resp" in
		all)	msg "Installing all sets."
			;;
		*)	for _set in $_resp; do
				sed -i -e "s/ $_set//g" install.conf
			done
			;;
	esac

	set -A _sets -- $(sed -n 's/Sets = //p' install.conf)
	for _set in "${_sets[@]}"; do
		chroot "$1" /usr/bin/apt-get install "$_set"
	done
}

# Setup grub
set_grub() {
	local _resp

	msg "Installing grub..."
	if [ -d "$1"/boot/efi ]; then
		# Install grub-efi
		chroot "$1" apt-get install grub-efi-amd64
		chroot "$1" grub-install --target=x86_64-efi \
			--efi-directory=/boot/efi
	else
		# Install grub-pc
		chroot "$1" apt-get install grub
		msg "Listing available devices..."
		chroot "$1" lsblk
		read -r _resp?"Which device should the bootloader be installed on? (e.g. /dev/sdX) "
		chroot "$1" grub-install "$_resp"
	fi
	chroot "$1" update-grub
}

# Cleanup.
cleanup() {
	rm /mnt/etc/resolv.conf

	# More to come
}

# Finishing touch
finish() {
	local _resp

	read -r _resp?"Installation complete. Type r (to reboot) or e (to exit and stay in the live session) then Return. "

	case "$_resp" in
		r)	loginctl reboot
			;;
		e)	exit 0
			;;
		*)	loginctl reboot
			;;
	esac
}

main() {
	get_tarball
	extract
	gfstab
	set_net
	set_tz
	set_hosts
	set_lokb
	set_rootpass
	set_user
	inst_kern
	install_sets
	set_grub
	cleanup
	finish
}

main 2>&1 | tee install.log
