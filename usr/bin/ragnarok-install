#!/bin/ksh

# Main installer script.
# $Ragnarok: ragnarok-install,v 1.73 2024/08/29 15:26:52 lecorbeau Exp $

set -e

. /usr/lib/ragnarok-installer/funcs

CONF=${CONF:-install.conf}
INSTALLTYPE=${INSTALLTYPE:-netinstall}
TMP=$(mktemp -d -p /tmp ragnarok-install.XXXXXXXXXX)
# Parse config values
MIRROR="https://github.com/RagnarokOS/distrib/releases/download/"
VERSION="01"
URL="${MIRROR}${VERSION}"

# Never download stuff off the internet as the root user.
# I take no credit for this function. All credit goes to
# Antoine Jacoutot, who wrote OpenBSD's syspatch(1).
unpriv() {
	local _file=$2 _ret=0 _user=_apt

	if [[ $1 == -f && -n ${_file} ]]; then
		# shellcheck disable=SC2188
		>${_file}
		chown "${_user}" "${_file}"
		chmod 0711 "${TMP}"
		shift 2
	fi
	(($# >= 1))

	su -s /bin/sh ${_user} -c "$@" || _ret=$?

	[[ -n ${_file} ]] && chown root "${_file}"

	return ${_ret}
}

## Funcs to ask questions (these may end up being moved to
## lib/ragnarok-install/funcs down the line.

# Ask conf question and store _answer as a variable.
ask() {
	local _q=$1 _resp

	read -r _resp?"$_q "
	_answer="$_resp"
}

# For some questions, lists of available choices need to be provided.
# $1 is the question
# $2 is the list
ask_q() {
	local _resp _q=$1 _list=$2

	read -r _resp?"$_q "
	case "$_resp" in
		l)	less --prompt="/ to search, j/k to navigate, q to quit, h for help " .local/src/ragnarok/installer/usr/share/ragnarok-installer/lists/"$_list".list; ask_q "$@"
			;;
		*)	_answer="$_resp"
			;;
	esac
}

# Ask for password.
# Much like unpriv(), I take no credit for ask_pass/ask_password. All
# credits go to the creator(s) of the OpenBSD installer.
ask_pass() {
	stty -echo
	IFS= read -r _resp?"$1 "
	stty echo
	echo
}

ask_password() {
	local _q=$1 _resp

	while :; do
		ask_pass "$_q (will not echo)"
		_password=$_resp

		ask_pass "$_q (again)"
		[[ $_resp == "$_password" ]] && break

		echo "Passwords don't match, try again."
	done
}

# Configure the device
dev_conf() {
	local _resp _homesize

	msg "Listing available devices..."
	echo
	lsblk
	echo
	ask "Which device should the system be installed on? (e.g. /dev/sdX): "
	_dev="$_answer"
	echo
	ask "Should the system boot in efi or legacy mode? "
	_mode="$_answer"
	ask "Size of the swap partition? (enter num + G, e.g. 8G): "
	_swap="$_answer"
	echo
	ask "Size of root (/)? (enter num + G, e.g. 30G): "
	_root="$_answer"
	echo
	ask "Size of /home? (enter num + G, or leave blank to use remainder of space on ${_dev}: "
	_home="$_answer"
	echo

	if [[ -z $_home ]]; then
		_homesize="using the remaining free space"
	else
		_homesize="$_home"
	fi

	case "$_mode" in
		efi)	_bootparttype="fat32"
			;;
		bios)	_bootparttype="ext4"
			;;
	esac

	read -r _resp?"The following partitions will be created on ${_dev}:

	a 500M $_bootparttype /boot partition on ${_dev}1,
	a swap partition of $_swap in size on ${_dev}2,
	an ext4 /root partition of $_root in size on ${_dev}3
	and an ext4 /home partition $_homesize on ${_dev}4.

	proceed? (Y/n): "

	# Restart if N/n
	if [[ $_resp == N ]] || [[ $_resp == n ]]; then
		msg "restarting..."
		dev_conf
	fi
}

# Ask all other config questions.
do_conf() {
	ask_q "Enter the timezine for this system, e.g. America/New_York. (Type l for a list of supported timezones): " tz
	_timezone="$_answer"
	echo
	ask_q "Enter the locale for this system, e.g. en_US.UTF-8 UTF-8. (Type l for a list of supported locales): " locales
	_locale="$_answer"
	echo
	ask_q "Enter the keymap for this system, e.g. us. (Type l for a list of supported keymaps): " xkblayout
	_kblayout="$_answer"
	echo
	ask "Enter the hostname for this machine: "
	_hostname="$_answer"
	echo
	ask_password "Enter the password for the root account: "
	_rootpass="$_password"
	ask "Setup a default user? (Y/n): "
	echo
	case "$_answer" in
		Y|y)
			ask "Name of default user: "
			_username="$_answer"
			echo
			ask_password "Enter the password for ${_username}: "
			_userpass="$_password"
			;;
		*)
			msg "Skipping user setup..."
			;;
	esac
	echo
}

### Funcs to actually install the system.

# Actually partition the device
part_dev() {
	# Wipe device
	sfdisk --delete "$_dev"

	# Set the proper part table (mbr for bios, GPT for EFI).
	case "$_mode" in
		bios)
			(echo o) | fdisk "$_dev"
			;;
		efi)
			(echo g) | fdisk "$_dev"
			;;
	esac

	# Set the boot partition type depending on boot mode
	case "$_mode" in
		bios)	_bootparttype="L"
			;;
		efi)	_bootparttype="U"
			;;
	esac

	printf '%s\n' "start=2048, size=500M, type=$_bootparttype
	size=${_swap}, type=S
	size=${_root}, type=L
	size=${_homesize}, type=L" | sfdisk "${_dev}"

	# Set bootable flag on partition 1.
	case "$_mode" in
		bios)	sfdisk -A "$_dev" 1
			;;
		efi)	sfdisk --part-type "$_dev" 1 U
			;;
	esac
}

# Create filesystems and mount the device
mount_dev() {
	case "$_mode" in
		bios)
			mkfs.ext4 "${_dev}1"
			;;
		efi)
			mkfs.vfat -F 32 "${_dev}1"
			;;
	esac
	mkswap "${_dev}2"
	# mkfs will ask to proceed anyway unless -F is used.
	mkfs.ext4 -F "${_dev}3"
	mkfs.ext4 -F "${_dev}4"

	swapon "${_dev}2"
	mount -t ext4 -o errors=remount-ro "${_dev}3" /mnt
	mkdir -p /mnt/{boot,home}
	mount -t ext4 -o defaults "${_dev}4" /mnt/home
	case "$_mode" in
		bios)
			mount -t ext4 -o noexec,nosuid,nodev "${_dev}1" /mnt/boot
			;;
		efi)
			mkdir -p /mnt/boot/efi
			mount -t vfat -o umask=0077,noexec,nosuid,nodev "${_dev}1" /mnt/boot/efi
			;;
	esac
}

# Wrapper function. Ask if the installer should proceed with partitioning the device.
mk_part() {
	local _dev _resp

	_dev=$(get_val Device "$CONF")

	read -r _resp?"The following device will be formatted: ${_dev}. All data will be erased. Proceed? (Y/n): "
	case "$_resp" in
		N|n)
			msg "Exiting installer. Start again..."
			exit 1
			;;
		Y|y)
			part_dev
			mount_dev
			;;
	esac
}

# Run the appropriate installer script.
do_install() {
	# We'll handle the other types of install (offline, etc...) later.
	case "$INSTALLTYPE" in
		netinstall)
			netinstall/install
			;;
		offline)
			msg "Not supported yet..."
			do_install
			;;
		*)
			netinstall/install
			;;
	esac
}

# Finishing touch
finish() {
	local _resp

	read -r _resp?"Installation complete. Type r (to reboot) or e (to exit and stay in the live session) then Return. "

	case "$_resp" in
		r)	loginctl reboot
			;;
		e)	exit 0
			;;
		*)	loginctl reboot
			;;
	esac
}

main() {
	part_dev
	mount_dev
	do_install
	finish
}

main 2>&1 | tee install.log
/usr/bin/mkdir -p /mnt/var/messages
/usr/bin/cp install.log /mnt/var/messages/
finish
